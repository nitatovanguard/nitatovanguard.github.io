import{V2 as t}from"./v2.mjs";const s=Math.PI/2.5;export class Ant{static foodPhDrop=.999;static nestPhDrop=.999;constructor(e,i,n){this.pos=new t(e,i),this.target=this.pos,this.carrying=!1,this.seeking=!1,this.speed=2,this.base=n,this.nestDetectionRange=100,this.foodDetectionRange=100,this.foodStrength=0,this.nestStrength=0,this.turnSpeed=.1,this.viewAngle=s,this.antennaLength=25,this.antennaSenseRadius=20;let h=Math.random()*Math.PI*2;this.dir=new t(Math.cos(h),Math.sin(h))}copyParams(t){this.speed=t.speed,this.nestDetectionRange=t.nestDetectionRange,this.foodDetectionRange=t.foodDetectionRange,this.turnSpeed=t.turnSpeed,this.viewAngle=t.viewAngle,this.antennaLength=t.antennaLength,this.antennaSenseRadius=t.antennaSenseRadius,this.dir=t.dir,this.updateAntennae()}clone(t,s,e){let i=new Ant(t,s,e);return i.copyParams(this),i}updateAntennae(){const t=Math.sin(.5*this.viewAngle),s=Math.cos(.5*this.viewAngle);this.leftAntenna=this.dir.rottrig(t,s).scale(this.antennaLength),this.rightAntenna=this.dir.rottrig(-t,s).scale(this.antennaLength)}isInsideNest(){return this.base.pos||console.log("isInsideNest"),this.pos.getSqDist(this.base.pos)<this.base.size**2}avoid(t){const s=this;t.ants.findAllInRadius(this.pos,40,t=>t!==s).forEach(t=>{const s=this.target.sub(this.pos).normalize(),e=t.pos.sub(this.pos);t.pos||console.log("avoid");const i=e.scaled(1/(Math.sqrt(this.pos.getSqDist(t.pos))+1e-4)*-1);this.carrying&&i.scale(.25),this.pos.addTo(s.average(i))})}lookForNest(t){return this.pos.sub(this.base.pos).sqLength()<this.nestDetectionRange**2&&(this.setTarget(this.base.pos),!0)}dropFoodinNest(t){return!!this.isInsideNest()&&(this.carrying=!1,this.base.addFood(1),this.nestStrength=1,this.flip(t),!0)}setTarget(t){this.target=t,this.seeking=!1}seek(){this.seeking=!0}tryPickupFood(t){const s=t.foods.findFirstInRadius(this.pos,10);return!!s&&(this.carrying=!0,t.foods.removeItem(s),this.foodStrength=1,this.flip(t),!0)}findFood(t){this.target.sub(this.pos);const s=t.foods.findNearestInRadius(this.pos,this.foodDetectionRange,t=>this.pos.isInView(t.pos,this.leftAntenna,this.rightAntenna));return!!s&&(this.setTarget(s.pos),s.target=!0,!0)}flip(t){this.dir.scale(-1),this.setTarget(this.pos.add(this.dir.scaled(10)))}followPheromone(t,s,e){const i=this.pos.add(this.leftAntenna),n=this.pos.add(this.rightAntenna);let h=t.detect(i,this.antennaSenseRadius),o=t.detect(n,this.antennaSenseRadius);if(0===h&&0===o)return!1;const a=h-o;return this.setTarget(this.pos.add(this.dir.rot(a))),!0}updatePosition(s){if(this.seeking&&this.pos.getSqDist(this.target)<10&&this.setTarget(new t(Math.random()*s.width,Math.random()*s.height)),this.seeking&&Math.random()<.05){let t=this.pos.add(this.dir.rot((2*Math.random()-1)*this.turnSpeed).scale(100*Math.random()));t=t.clip(0,s.width,0,s.height),this.setTarget(t)}let e=this.target.sub(this.pos).normalize();if(this.dir.perpdot(e)<0){const t=this.dir.rot(this.turnSpeed);this.dir=e.perpdot(t)>0?t:e}else{const t=this.dir.rot(-this.turnSpeed);this.dir=e.perpdot(t)<0?t:e}this.updateAntennae(),this.pos.addTo(this.dir.scaled(this.speed)),this.foodStrength*=Ant.foodPhDrop,this.nestStrength*=Ant.nestPhDrop}update(t){this.isInsideNest()&&(this.nestStrength=1),this.carrying?this.dropFoodinNest(t)?this.seek():(this.lookForNest(t)||this.followPheromone(t.nestph,"base",t)||this.seek(),t.foodph.add(this.pos,this.foodStrength)):(!this.tryPickupFood(t)&&this.findFood(t)||this.followPheromone(t.foodph,"food",t)||this.seek(),t.nestph.add(this.pos,this.nestStrength)),this.updatePosition(t)}}export default{Ant};